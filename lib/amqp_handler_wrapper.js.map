{"version":3,"sources":["../src/amqp_handler_wrapper.js"],"names":["_","require","Promise","config","getDefaultDelay","attempts","delay","Math","pow","module","exports","channel","clientQueueName","failureQueueName","clientHandler","delayFunction","retryCount","initializer","errorHandler","msg","isInitialized","then","defaults","properties","headers","_retryCount","isNaN","sendToQueue","Buffer","content","expiration","persistent","_originalProperties","_targetQueue","extend","toString","publish","delayQueueName","handlerWrapper","try","catch","err","console","error","nack","ack"],"mappings":"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","file":"amqp_handler_wrapper.js","sourcesContent":["const _ = require('underscore')\nconst Promise = require('bluebird')\nconst config = require('./config')\n\n// attempts must be a number in milliseconds\nconst getDefaultDelay = (attempts) => {\n  const delay = Math.pow(2, attempts)\n  if (delay > 60 * 60 * 24) {\n    // the delay for the message is longer than 24 hours.  Fail the message and never retry again.\n    return -1\n  }\n  return delay * 1000\n}\n\nmodule.exports = function (channel, clientQueueName, failureQueueName, clientHandler, delayFunction, retryCount, initializer) {\n  const errorHandler = (msg) => {\n    if (!initializer.isInitialized) {\n      // Delay in 1 MS to let the queues/exchange/bindings initialize\n      return Promise\n        .delay(1)\n        .then(() => errorHandler(msg))\n    }\n\n    _.defaults(msg, { properties: {} })\n    _.defaults(msg.properties, { headers: {} })\n    _.defaults(msg.properties.headers, { _retryCount: 0 }) // _retryCount: 0 means this message has never been retried before.\n\n    if(!isNaN(retryCount) && retryCount >= msg.properties.headers._retryCount){\n      return channel.sendToQueue(failureQueueName, new Buffer(msg.content), msg.properties)\n    }\n\n    msg.properties.headers._retryCount += 1\n    const expiration = (delayFunction || getDefaultDelay)(msg.properties.headers._retryCount)\n\n    if (expiration < 1) {\n      return channel.sendToQueue(failureQueueName, new Buffer(msg.content), msg.properties)\n    }\n\n    const properties = {\n      persistent: true,\n      headers: {\n        _originalProperties: msg.properties, // save the original properties.\n        _targetQueue: clientQueueName // save the target queue name we should publish to after the delay is over.\n      }\n    }\n\n    _.extend(properties, {\n      expiration: expiration.toString()\n    })\n\n    return channel.publish('', config.delayQueueName, new Buffer(msg.content), properties)\n  }\n\n  const handlerWrapper = (msg) =>\n    Promise\n      .try(() => clientHandler(msg))\n      .catch((err) => {\n        // Something went wrong. Let's handle this message.\n        // Adding the string 'error' to support papertrail error filters.\n        console.error('Error: AMQP retry handler caught the following error: ', err)\n        return Promise\n          .try(() => errorHandler(msg))\n          .catch((err) => {\n            // Something went wrong while trying to process the erroneous message.\n            // Sending nack so the client can try to process it again.\n            channel.nack(msg)\n            throw err\n          })\n      })\n      .then(() =>\n        // We ack it for the user. Either way if the message has been processed successfully or\n        // not, the message should be out of the original queue, therefore - acked.\n        channel.ack(msg)\n      )\n\n  return handlerWrapper\n}\n\n"]}